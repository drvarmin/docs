---
title: "Advanced Purchasing"
description: "If you need fine-grain control over the purchasing pipeline, use a purchase controller to manually handle purchases and subscription status."
---

<Warning>
  Using a `PurchaseController` is only recommended for **advanced** use cases. By default, Superwall handles all
  subscription-related logic and purchasing operations for you out of the box.
</Warning>

By default, Superwall handles basic subscription-related logic for you:

1. **Purchasing**: When the user initiates a checkout on a paywall.
2. **Restoring**: When the user restores previously purchased products.
3. **Subscription Status**: When the user's subscription status changes to active or expired (by checking the local receipt).

However, if you want more control, you can pass in a `PurchaseController` when configuring the SDK via `configure(apiKey:purchaseController:options:)` and manually set `Superwall.shared.subscriptionStatus` to take over this responsibility.

### Step 1: Creating a `PurchaseController`

A `PurchaseController` handles purchasing and restoring via protocol methods that you implement.

:::ios
<CodeGroup>

```swift Swift
// MyPurchaseController.swift

import SuperwallKit
import StoreKit

final class MyPurchaseController: PurchaseController {
  static let shared = MyPurchaseController()

  // 1
  func purchase(product: StoreProduct) async -> PurchaseResult {
    // Use StoreKit or some other SDK to purchase...
    // Send Superwall the result.
    return .purchased // .cancelled,  .pending, .failed(Error)
  }

  func restorePurchases() async -> RestorationResult {
    // Use StoreKit or some other SDK to restore...
    // Send Superwall the result.
    return .restored // Or failed(error)
  }
}
```

```swift Objective-C
@import SuperwallKit;
@import StoreKit;

// MyPurchaseController

@interface MyPurchaseController: NSObject <SWKPurchaseController>
  + (instancetype)sharedInstance;
@end

@implementation MyPurchaseController

+ (instancetype)sharedInstance
{
  static MyPurchaseController *sharedInstance = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    sharedInstance = [MyPurchaseController new];
  });
  return sharedInstance;
}

// 1
- (void)purchaseWithProduct:(SWKStoreProduct * _Nonnull)product completion:(void (^ _Nonnull)(enum SWKPurchaseResult, NSError * _Nullable))completion {

  // TODO
  // ----
  // Purchase via StoreKit, RevenueCat, Qonversion or however
  // you like and return a valid SWKPurchaseResult

  completion(SWKPurchaseResultPurchased, nil);
}

// 2
- (void)restorePurchasesWithCompletion:(void (^ _Nonnull)(enum SWKRestorationResult, NSError * _Nullable))completion {

  // TODO
  // ----
  // Restore purchases and return `SWKRestorationResultRestored` if successful.
  // Return an `NSError` if not.

  completion(SWKRestorationResultRestored, nil);
}

@end
```
</CodeGroup>
<br />
<AccordionGroup>
<Accordion title="Complete example for iOS">
  ```swift
import StoreKit
import SuperwallKit

final class SWPurchaseController: PurchaseController {
    // MARK: Sync Subscription Status
    /// Makes sure that Superwall knows the customer's subscription status by
    /// changing `Superwall.shared.subscriptionStatus`
    func syncSubscriptionStatus() async {
      /// Every time the customer info changes, the subscription status should be updated.
      for await _ in Superwall.shared.customerInfoStream {
        var products: Set<String> = []
        for await verificationResult in Transaction.currentEntitlements {
          switch verificationResult {
          case .verified(let transaction):
            products.insert(transaction.productID)
          case .unverified:
            break
          }
        }

        let activeDeviceEntitlements = Superwall.shared.entitlements.byProductIds(products)
        let activeWebEntitlements = Superwall.shared.entitlements.web
        let allActiveEntitlements = activeDeviceEntitlements.union(activeWebEntitlements)

        await MainActor.run {
          Superwall.shared.subscriptionStatus = .active(allActiveEntitlements)
        }
      }
    }

    // MARK: Handle Purchases
    /// Makes a purchase with Superwall and returns its result after syncing subscription status. This gets called when
    /// someone tries to purchase a product on one of your paywalls.
    func purchase(product: StoreProduct) async -> PurchaseResult {
      let result = await Superwall.shared.purchase(product)
      return result
    }

    // MARK: Handle Restores
    /// Makes a restore with Superwall and returns its result after syncing subscription status.
    /// This gets called when someone tries to restore purchases on one of your paywalls.
    func restorePurchases() async -> RestorationResult {
      let result = await Superwall.shared.restorePurchases()
      return result
    }
}
```
</Accordion>
</AccordionGroup>
:::
:::android
```kotlin Kotlin
// MyPurchaseController.kt

class MyPurchaseController(val context: Context): PurchaseController {

  // 1
  override suspend fun purchase(
    activity: Activity,
    productDetails: ProductDetails,
    basePlanId: String?,
    offerId: String?
  ): PurchaseResult {

    // TODO
    // ----
    // Purchase via GoogleBilling, RevenueCat, Qonversion or however
    // you like and return a valid PurchaseResult

    return PurchaseResult.Purchased()
  }

  // 2
  override suspend fun restorePurchases(): RestorationResult {

    // TODO
    // ----
    // Restore purchases and return true if successful.

    return RestorationResult.Success()
  }
}
```
:::
:::flutter
```dart Flutter
// MyPurchaseController.dart

class MyPurchaseController extends PurchaseController {
  // 1
  @override
  Future<PurchaseResult> purchaseFromAppStore(String productId) async {

    // TODO
    // ----
    // Purchase via StoreKit, RevenueCat, Qonversion or however
    // you like and return a valid PurchaseResult

    return PurchaseResult.purchased;
  }

  @override
  Future<PurchaseResult> purchaseFromGooglePlay(
    String productId,
    String? basePlanId,
    String? offerId
  ) async {

    // TODO
    // ----
    // Purchase via Google Billing, RevenueCat, Qonversion or however
    // you like and return a valid PurchaseResult

    return PurchaseResult.purchased;
  }

  // 2
  @override
  Future<RestorationResult> restorePurchases() async {

    // TODO
    // ----
    // Restore purchases and return true if successful.

    return RestorationResult.restored;
  }
}
```
:::
:::expo
```typescript React Native
export class MyPurchaseController extends PurchaseController {
  // 1
  async purchaseFromAppStore(productId: string): Promise<PurchaseResult> {
    // TODO
    // ----
    // Purchase via StoreKit, RevenueCat, Qonversion or however
    // you like and return a valid PurchaseResult
  }

  async purchaseFromGooglePlay(
    productId: string,
    basePlanId?: string,
    offerId?: string
  ): Promise<PurchaseResult> {
    // TODO
    // ----
    // Purchase via Google Billing, RevenueCat, Qonversion or however
    // you like and return a valid PurchaseResult
  }

  // 2
  async restorePurchases(): Promise<RestorationResult> {
    // TODO
    // ----
    // Restore purchases and return true if successful.
  }
}
```
:::

Hereâ€™s what each method is responsible for:

1. Purchasing a given product. In here, enter your code that you use to purchase a product. Then, return the result of the purchase as a `PurchaseResult`. For Flutter, this is separated into purchasing from the App Store and Google Play. This is an enum that contains the following cases, all of which must be handled:
   1. `.cancelled`: The purchase was cancelled.
   2. `.purchased`: The product was purchased.
   3. `.pending`: The purchase is pending/deferred and requires action from the developer.
   4. `.failed(Error)`: The purchase failed for a reason other than the user cancelling or the payment pending.
2. Restoring purchases. Here, you restore purchases and return a `RestorationResult` indicating whether the restoration was successful or not. If it was, return `.restore`, or `failed` along with the error reason.

### Step 2: Configuring the SDK With Your `PurchaseController`

Pass your purchase controller to the `configure(apiKey:purchaseController:options:)` method:

:::ios
<CodeGroup>

```swift UIKit
// AppDelegate.swift

import UIKit
import SuperwallKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

    Superwall.configure(
      apiKey: "MY_API_KEY",
      purchaseController: MyPurchaseController.shared // <- Handle purchases on your own
    )

    return true
  }
}
```

```swift SwiftUI
@main
struct MyApp: App {

  init() {
    Superwall.configure(
      apiKey: "MY_API_KEY",
      purchaseController: MyPurchaseController.shared // <- Handle purchases on your own
    )
  }
  
  var body: some Scene {
    WindowGroup {
      ContentView()
    }
  }
}
```

```swift Objective-C
// AppDelegate.m

@import SuperwallKit;

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // Override point for customization after application launch.
  [Superwall configureWithApiKey:@"MY_API_KEY" purchaseController:[MyPurchaseController sharedInstance] options:nil completion:nil];
  return YES;
}
```
</CodeGroup>
:::
:::android

```kotlin Kotlin
// MainApplication.kt

class MainApplication : android.app.Application(), SuperwallDelegate {

    override fun onCreate() {
        super.onCreate()

        Superwall.configure(this, "MY_API_KEY", MyPurchaseController(this))
        // OR using the DSL
        configureSuperwall("MY_API_KEY") {
           purchaseController = MyPurchaseController(this@MainApplication)
        }
    }
}

```
:::
:::flutter
```dart Flutter
// main.dart

void initState() {
  // Determine Superwall API Key for platform
  String apiKey = Platform.isIOS ? "MY_IOS_API_KEY" : "MY_ANDROID_API_KEY";

  // Create the purchase controller
  MyPurchaseController purchaseController = MyPurchaseController();

  Superwall.configure(apiKey, purchaseController);
}
```
:::
:::expo
```typescript React Native
export default function App() {
  React.useEffect(() => {
    const apiKey = Platform.OS === "ios" ? "MY_IOS_API_KEY" : "MY_ANDROID_API_KEY"
    const purchaseController = new MyPurchaseController()
    Superwall.configure({
      apiKey: apiKey,
      purchaseController: purchaseController,
    })
  }, [])
}
```
:::

### Step 3: Keeping `subscriptionStatus` Up-To-Date

You **must** set `Superwall.shared.subscriptionStatus` every time the user's subscription status changes, otherwise the SDK won't know who to show a paywall to. This is an enum that has three possible cases:

1. **`.unknown`**: This is the default value. In this state, paywalls will not show and their presentation will be **_automatically delayed_** until `subscriptionStatus` changes to a different value.
2. **`.active(let entitlements)`**: Indicates that the user has an active entitlement. Paywalls will not show in this state unless you remotely set the paywall to ignore subscription status. A user can have one or more active entitlement.
3. **`.inactive`**: Indicates that the user doesn't have an active entitlement. Paywalls can show in this state.

Here's how you might do this:

:::ios
<CodeGroup>
```swift Swift
import SuperwallKit

func syncSubscriptionStatus() async {
  var purchasedProductIds: Set<String> = []

  // get all purchased product ids
  for await verificationResult in Transaction.currentEntitlements {
    switch verificationResult {
    case .verified(let transaction):
      purchasedProductIds.insert(transaction.productID)
    case .unverified:
      break
    }
  }

  // get entitlements from purchased product ids from Superwall
  let entitlements = Superwall.shared.entitlements.byProductIds(products)

  // set subscription status
  await MainActor.run {
    Superwall.shared.subscriptionStatus = .active(entitlements)
  }
}
```

```swift Objective-C
@import SuperwallKit;

// when a subscription is purchased, restored, validated, expired, etc...
[myService setSubscriptionStatusDidChange:^{
  if (user.hasActiveSubscription) {
    [Superwall sharedInstance] setActiveSubscriptionStatusWith:[NSSet setWithArray:@[myEntitlements]]];
  } else {
    [[Superwall sharedInstance] setInactiveSubscriptionStatus];
  }
}];
```
</CodeGroup>
:::
:::android
```kotlin Kotlin
// When a subscription is purchased, restored, validated, expired, etc...
myService.subscriptionStatusDidChange {
  if (it.hasActiveSubscription) {
    Superwall.instance.setSubscriptionStatus(SubscriptionStatus.Active(entitlements))
  } else {
    Superwall.instance.setSubscriptionStatus(SubscriptionStatus.Inactive(entitlements))
  }
}
```
:::
:::flutter
```dart Flutter
// When a subscription is purchased, restored, validated, expired, etc...
myService.addSubscriptionStatusListener((subscriptionInfo) {
  var entitlements = subscriptionInfo.entitlements.active.keys
    .map((id) => Entitlement(id: id))
    .toSet();
  var hasActiveSubscription = subscriptionInfo.isActive;

  if (hasActiveSubscription) {
    Superwall.shared.setSubscriptionStatus(SubscriptionStatusActive(entitlements: entitlements));
  } else {
    Superwall.shared.setSubscriptionStatus(SubscriptionStatusInactive());
  }
});
```
:::
:::expo
```typescript React Native
// When a subscription is purchased, restored, validated, expired, etc...
myService.addSubscriptionStatusListener((subscriptionInfo: SubscriptionInfo) => {
  const entitlements = Object.keys(subscriptionInfo.entitlements.active).map((id) => ({
    id,
  }))
  if (entitlements.length === 0) {
    Superwall.shared.setSubscriptionStatus(SubscriptionStatus.Inactive())
  } else {
    Superwall.shared.setSubscriptionStatus(
      SubscriptionStatus.Active(entitlements.map((id) => new Entitlement(id)))
    )
  }
})
```
:::

<br />
<Note> `subscriptionStatus` is cached between app launches </Note>

### Listening for subscription status changes

If you need a simple way to observe when a user's subscription status changes, on iOS you can use the `Publisher` for it. Here's an example:

:::ios
```swift iOS
subscribedCancellable = Superwall.shared.$subscriptionStatus
  .receive(on: DispatchQueue.main)
  .sink { [weak self] status in
    switch status {
    case .unknown:
      self?.subscriptionLabel.text = "Loading subscription status."
    case .active(let entitlements):
      self?.subscriptionLabel.text = "You currently have an active subscription: \(entitlements.map { $0.id }). Therefore, the paywall will not show unless feature gating is disabled."
    case .inactive:
      self?.subscriptionLabel.text = "You do not have an active subscription so the paywall will show when clicking the button."
    }
  }
```
:::
:::android
```kotlin Kotlin
Superwall.instance.subscriptionStatus.collect { status: SubscriptionStatus ->
 // React to changes
}
```
:::
:::flutter
```dart Flutter
Superwall.shared.subscriptionStatus.listen((status) {
   // React to changes
}

//Or use SuperwallBuilder widget which triggers the builder closure when subscription status changes
SuperwallBuilder(
  builder: (context, status) => Center(
        child: Text('Subscription Status: ${status}'),
  )
  )
```
:::
:::expo
```typescript React Native
Superwall.shared.subscriptionStatusEmitter.addListener("change", (status) => {
  switch (status.status) {
    case "ACTIVE":
      break
    default:
      break
  }
})
```
:::

You can do similar tasks with the `SuperwallDelegate`, such as [viewing which product was purchased from a paywall](/3rd-party-analytics#using-events-to-see-purchased-products).
